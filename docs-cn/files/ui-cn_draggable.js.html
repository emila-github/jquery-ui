<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>ui-cn\draggable.js - jquery-ui</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="jquery-ui"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.11.2-pre</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/$.extend.html">$.extend</a></li>
            
                <li><a href="../classes/$.ui.html">$.ui</a></li>
            
                <li><a href="../classes/$.ui.plugin.html">$.ui.plugin</a></li>
            
                <li><a href="../classes/ui.draggable.html">ui.draggable</a></li>
            
                <li><a href="../classes/ui.mouse.html">ui.mouse</a></li>
            
                <li><a href="../classes/ui.widget.html">ui.widget</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/bridge.html">bridge</a></li>
            
                <li><a href="../modules/draggable.html">draggable</a></li>
            
                <li><a href="../modules/mouse.html">mouse</a></li>
            
                <li><a href="../modules/ui.html">ui</a></li>
            
                <li><a href="../modules/widget.html">widget</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: ui-cn\draggable.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*!
 * jQuery UI Draggable @VERSION
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/draggable/
 */
(function( factory ) {
	if ( typeof define === &quot;function&quot; &amp;&amp; define.amd ) {

		// AMD. Register as an anonymous module.
		define([
			&quot;jquery&quot;,
			&quot;./core&quot;,
			&quot;./mouse&quot;,
			&quot;./widget&quot;
		], factory );
	} else {

		// Browser globals
		factory( jQuery );
	}
}(function( $ ) {

/**
 * 可拖拽小部件（Draggable Widget）&lt;br/&gt;
 * 允许使用鼠标移动元素。&lt;br/&gt;
 *
 * 注释：让被选元素可被鼠标拖拽。如果您不只是拖拽，而是拖拽 &amp; 放置，请查看 jQuery UI 可放置（Droppable）插件，为可拖拽元素提供了一个放置目标。&lt;br/&gt;
 *
 * @class draggable
 * @module draggable
 * @requires core,mouse,widget
 * @constructor
 * @namespace ui
 */


$.widget(&quot;ui.draggable&quot;, $.ui.mouse, {
	version: &quot;@VERSION&quot;,
	widgetEventPrefix: &quot;drag&quot;,
	/**
	 * 一个包含小部件当前使用选项的对象。
	 * 在实例化时，用户提供的任何选项将会自动与 $.myNamespace.myWidget.prototype.options 中定义的默认值合并。用户指定的选项会覆盖默认值。
	 * 
	 * @property options
	 * @type {Object}
	 */
	options: {
		/**
		 * 如果设置为 false，将阻止 ui-draggable class 被添加。当在数百个元素上调用 .draggable() 时，这么设置有利于性能优化。
		 * @property options.addClasses
		 * @type {Boolean}
		 * @example
		 *	//初始化带有指定 addClasses 选项的 draggable：
		 *	$( &quot;.selector&quot; ).draggable({ addClasses: false });
		 *	
		 */
		addClasses: true, 
		/**
		 * 当拖拽时，draggable 助手（helper）要追加到哪一个元素。&lt;br/&gt;
		 * 支持多个类型：&lt;br/&gt;
		 * jQuery：一个 jQuery 对象，包含助手（helper）要追加到的元素。&lt;br/&gt;
		 * Element：要追加助手（helper）的元素。&lt;br/&gt;
		 * Selector：一个选择器，指定哪一个元素要追加助手（helper）。&lt;br/&gt;
		 * String：字符串 &quot;parent&quot; 将促使助手（helper）成为 draggable 的同级。&lt;br/&gt;
		 * 
		 * @property options.appendTo
		 * @type {jQuery | Element | Selector | String}
		 * @default &quot;parent&quot;
		 * @example
		 *	//初始化带有指定 axis 选项的 draggable：
		 *	$( &quot;.selector&quot; ).draggable({ axis: &quot;x&quot; });
		 */
		appendTo: &quot;parent&quot;,  
		/**
		 * 约束在水平轴 (x) 或垂直轴 (y) 上拖拽。可能的值：&quot;x&quot;, &quot;y&quot;。
		 * @property options.axis
		 * @type {String}
		 * @default false
		 * @example
		 *	//初始化带有指定 appendTo 选项的 draggable：
		 *	$( &quot;.selector&quot; ).draggable({ appendTo: &quot;body&quot; });
		 */
		axis: false, 
		/**
		 * 允许 draggable 放置在指定的 sortable 上。
		 * 如果使用了该选项，一个 draggable 可被放置在一个 sortable 列表上，然后成为列表的一部分。
		 * 注意：helper 选项必须设置为 &quot;clone&quot;，以便更好地工作。
		 * 必须包含 可排序小部件（Sortable Widget）。
		 * @property options.connectToSortable
		 * @type {Boolean}
		 * @default false
		 * @example
		 *	//初始化带有指定 connectToSortable 选项的 draggable：
		 *	$( &quot;.selector&quot; ).draggable({ connectToSortable: &quot;#my-sortable&quot; });
		 */
		connectToSortable: false,
		/**
		 * 约束在指定元素或区域的边界内拖拽。&lt;br/&gt;
		 * 支持多个类型：&lt;br/&gt;
		 * Selector：可拖拽元素将被包含在 selector 第一个元素的边界内。如果未找到元素，则不设置 containment。&lt;br/&gt;
		 * Element：可拖拽元素将被韩寒在元素的边界。&lt;br/&gt;
		 * String：可能的值：&quot;parent&quot;、&quot;document&quot;、&quot;window&quot;。&lt;br/&gt;
		 * Array：一个数组， 以形式 [ x1, y1, x2, y2 ] 定义元素的边界。&lt;br/&gt;
		 *
		 * @property options.containment
		 * @type {Selector | Element | String | Array | Boolean}
		 * @default false
		 * @example
		 *	//初始化带有指定 containment 选项的 draggable：
		 *	$( &quot;.selector&quot; ).draggable({ containment: &quot;parent&quot; });
		 *	//在初始化后，获取或设置 containment 选项：
		 *	// getter
		 *	var containment = $( &quot;.selector&quot; ).draggable( &quot;option&quot;, &quot;containment&quot; );
		 *	// setter
		 *	$( &quot;.selector&quot; ).draggable( &quot;option&quot;, &quot;containment&quot;, &quot;parent&quot; );
		 *	
		 */
		containment: false,
		/**
		 * 拖拽操作期间的 CSS 光标。&lt;br/&gt;
		 * 有效的 CSS 光标值包括：default、move、pointer、crosshair，等等。
		 *
		 * @property options.cursor
		 * @type {String}
		 * @default &quot;auto&quot;
		 * @example
		 *	//初始化带有指定 cursor 选项的 draggable：
		 *	$( &quot;.selector&quot; ).draggable({ cursor: &quot;crosshair&quot; });
		 */
		cursor: &quot;auto&quot;,
		/**
		 * 使用 cursorAt 选项来指定相对于 draggable 的另一个位置（指定一个相对于 top、right、bottom、left 的像素值）
		 *
		 * @property options.cursorAt
		 * @type {Object}
		 * @default false
		 * @example
		 *	//初始化带有指定 cursorAt 选项的 draggable：
		 *	$( &quot;.selector&quot; ).draggable({ cursorAt: { top: -5, left: -5} });
		 */
		cursorAt: false,
		/**
		 * 对齐拖拽助手（helper）到网格，每个 x 和 y 像素。数组形式必须是 [ x, y ]。
		 *
		 * @property options.grid
		 * @type {Array}
		 * @default false
		 * @example
		 *	//初始化带有指定 grid 选项的 draggable：
		 *	$( &quot;.selector&quot; ).draggable({ grid: [ 50, 20 ] });
		 */
		grid: false,
		/**
		 * 如果指定了该选项，则限制开始拖拽，除非鼠标在指定的元素上按下。
		 * 只有可拖拽（draggable）元素的后代元素才允许被拖拽。
		 *
		 * @property options.handle
		 * @type {Selector | Element}
		 * @default false
		 * @example
		 *	//初始化带有指定 handle 选项的 draggable：
		 *	$( &quot;.selector&quot; ).draggable({ handle: &quot;h2&quot; });
		 */
		handle: false,
		/**
		 * 允许一个 helper 元素用于拖拽显示。&lt;br/&gt;
		 * 支持多个类型：&lt;br/&gt;
		 * String：如果设置为 &quot;clone&quot;，元素将被克隆，且克隆将被拖拽。&lt;br/&gt;
		 * Function：一个函数，将返回拖拽时要使用的 DOMElement。&lt;br/&gt;
		 *
		 * @property options.helper
		 * @type {String | Function}
		 * @default false
		 * @example
		 *	//初始化带有指定 helper 选项的 draggable：
		 *	$( &quot;.selector&quot; ).draggable({ helper: &quot;clone&quot; });
		 *	//初始化带有指定 helper function 选项的 draggable：
		 *	$( &quot;.selector&quot; ).draggable({
		 *		helper: function( event ) {
		 *			return $( &quot;&lt;div class=&#x27;ui-widget-header&#x27;&gt;I&#x27;m a custom helper&lt;/div&gt;&quot; );
		 *		}
		 *	});
		 */
		helper: &quot;original&quot;,
		/**
		 * 防止拖拽期间 iframes 捕捉鼠标移动（mousemove ）事件。
		 * 在与 cursorAt 选项结合使用时，或鼠标光标未覆盖在助手（helper）上时，非常有用。&lt;br/&gt;
		 *
		 * 支持多个类型：&lt;br/&gt;
		 * Boolean：当设置为 true 时，透明遮罩将被放置在页面上所有 iframes 上。&lt;br/&gt;
		 * Selector：匹配 selector 的任意 iframes 将被透明遮罩覆盖。&lt;br/&gt;
		 *
		 * @property options.iframeFix
		 * @type {Boolean | Selector}
		 * @default false
		 * @example
		 *	//初始化带有指定 iframeFix 选项的 draggable：
		 *	$( &quot;.selector&quot; ).draggable({ iframeFix: true });
		 */
		iframeFix: false,
		/**
		 * 当被拖拽时助手（helper）的不透明度。
		 *
		 * @property options.opacity
		 * @type {Number}
		 * @default false
		 * @example
		 *	//初始化带有指定 opacity 选项的 draggable：
		 *	$( &quot;.selector&quot; ).draggable({ opacity: 0.35 });
		 */
		opacity: false,
		/**
		 * 如果设置为 true，在每次鼠标移动（mousemove）时都会计算所有可放置的位置。
		 * 注意：这解决了高度动态的问题，但是明显降低了性能。
		 *
		 * @property options.refreshPositions
		 * @type {Boolean}
		 * @default false
		 * @example
		 *	//初始化带有指定 refreshPositions 选项的 draggable：
		 *	$( &quot;.selector&quot; ).draggable({ refreshPositions: true });
		 */
		refreshPositions: false,
		/**
		 * 当拖拽停止时，元素是否还原到它的开始位置。&lt;br/&gt;
		 * 支持多个类型：&lt;br/&gt;
		 * Boolean：如果设置为 true，元素总会还原。&lt;br/&gt;
		 * String：如果设置为 &quot;invalid&quot;，还原仅在 draggable 未放置在 droppable 上时发生，如果设置为 &quot;valid&quot; 则相反。&lt;br/&gt;
		 * Function：一个函数，确定元素是否还原到它的开始位置。该函数必须返回 true 才能还原元素。&lt;br/&gt;
		 *
		 * @property options.revert
		 * @type {Boolean | String | Function}
		 * @default false
		 * @example
		 *	//初始化带有指定 revert 选项的 draggable：
		 *	$( &quot;.selector&quot; ).draggable({ revert: true });
		 */
		revert: false,
		/**
		 * 还原（revert）动画的持续时间，以毫秒计。如果 revert 选项是 false 则忽略。
		 *
		 * @property options.revertDuration
		 * @type {Number}
		 * @default 500
		 * @example
		 *	//初始化带有指定 revertDuration 选项的 draggable：
		 *	$( &quot;.selector&quot; ).draggable({ revertDuration: 200 });
		 */
		revertDuration: 500,
		/**
		 * 用于组合配套 draggable 和 droppable 项，除了 droppable 的 accept 选项之外。
		 * 一个与 droppable 带有相同的 scope 值的 draggable 会被该 droppable 接受。
		 *
		 * @property options.scope
		 * @type {String}
		 * @default &quot;default&quot;
		 * @example
		 *	//初始化带有指定 scope 选项的 draggable：
		 *	$( &quot;.selector&quot; ).draggable({ scope: &quot;tasks&quot; });
		 */
		scope: &quot;default&quot;,
		/**
		 * 如果设置为 true，当拖拽时容器会自动滚动。
		 *
		 * @property options.scroll
		 * @type {Boolean}
		 * @default true
		 * @example
		 *	//初始化带有指定 scroll 选项的 draggable：
		 *	$( &quot;.selector&quot; ).draggable({ scroll: false });
		 */
		scroll: true,
		/**
		 * 从要滚动的视区边缘起的距离，以像素计。距离是相对于指针的，不是相对于 draggable。
		 * 如果 scroll 选项是 false 则忽略。
		 *
		 * @property options.scrollSensitivity
		 * @type {Number}
		 * @default 20
		 * @example
		 *	//初始化带有指定 scrollSensitivity 选项的 draggable：
		 *	$( &quot;.selector&quot; ).draggable({ scroll: false });
		 */
		scrollSensitivity: 20,
		/**
		 * 当鼠标指针获取到在 scrollSensitivity 距离内时，窗体滚动的速度。
		 * 如果 scroll 选项是 false 则忽略。
		 *
		 * @property options.scrollSpeed
		 * @type {Number}
		 * @default 20
		 * @example
		 *	//初始化带有指定 scrollSpeed 选项的 draggable：
		 *	$( &quot;.selector&quot; ).draggable({ scrollSpeed: 100 });
		 */
		scrollSpeed: 20,
		/**
		 * 元素是否对齐到其他元素。&lt;br/&gt;
		 * 支持多个类型：&lt;br/&gt;
		 * Boolean：当设置为 true 时，元素会对齐到其它可拖拽（draggable ）元素。&lt;br/&gt;
		 * Selector：一个选择器，指定要对齐到哪个元素。&lt;br/&gt;
		 *
		 * @property options.snap
		 * @type {Boolean | Selector}
		 * @default false
		 * @example
		 *	//初始化带有指定 snap 选项的 draggable：
		 *	$( &quot;.selector&quot; ).draggable({ snap: true });
		 */
		snap: false,
		/**
		 * 决定 draggable 将对齐到对齐元素的哪个边缘。如果 snap 选项是 false 则忽略。
		 * 可能的值：&quot;inner&quot;、&quot;outer&quot;、&quot;both&quot;。
		 *
		 * @property options.snapMode
		 * @type {String}
		 * @default &quot;both&quot;
		 * @example
		 *	//初始化带有指定 snapMode 选项的 draggable：
		 *	$( &quot;.selector&quot; ).draggable({ snapMode: &quot;inner&quot; });
		 */
		snapMode: &quot;both&quot;,
		/**
		 * 从要发生对齐的对齐元素边缘起的距离，以像素计。
		 * 如果 snap 选项是 false 则忽略。
		 *
		 * @property options.snapTolerance
		 * @type {Number}
		 * @default 20
		 * @example
		 *	//初始化带有指定 snapTolerance 选项的 draggable：
		 *	$( &quot;.selector&quot; ).draggable({ snapTolerance: 30 });
		 */
		snapTolerance: 20,
		/**
		 * 控制匹配选择器（selector）的元素集合的 z-index，总是在当前拖拽项的前面，在类似窗口管理器这样的事物中非常有用。
		 *
		 * @property options.stack
		 * @type {Selector}
		 * @default false
		 * @example
		 *	//初始化带有指定 stack 选项的 draggable：
		 *	$( &quot;.selector&quot; ).draggable({ stack: &quot;.products&quot; });
		 */
		stack: false,
		/**
		 * 当被拖拽时，助手（helper）的 Z-index。
		 *
		 * @property options.zIndex
		 * @type {Number}
		 * @default false
		 * @example
		 *	//初始化带有指定 zIndex 选项的 draggable：
		 *	$( &quot;.selector&quot; ).draggable({ zIndex: 100 });
		 */
		zIndex: false,

		// callbacks
		drag: null,
		start: null,
		stop: null

		/**
		 * 防止从指定的元素上开始拖拽。
		 *
		 * @property options.cancel
		 * @type {Selector}
		 * @default &quot;input, textarea, button, select, option&quot;
		 * @example
		 *	//初始化带有指定 cancel 选项的 draggable：
		 *	$( &quot;.selector&quot; ).draggable({ cancel: &quot;.title&quot; });
		 */

		/**
		 * 鼠标按下后直到拖拽开始为止的时间，以毫秒计。该选项可以防止点击在某个元素上时不必要的拖拽。
		 *
		 * @property options.delay
		 * @type {Boolean}
		 * @default false
		 * @example
		 *	//初始化带有指定 delay 选项的 draggable：
		 *	$( &quot;.selector&quot; ).draggable({ delay: 300 });
		 */

		/**
		 * 如果设置为 true，则禁用该 draggable。
		 *
		 * @property options.disabled
		 * @type {Boolean}
		 * @default false
		 * @example
		 *	//初始化带有指定 disabled 选项的 draggable：
		 *	$( &quot;.selector&quot; ).draggable({ disabled: true });
		 */
		
		/**
		 * 鼠标按下后拖拽开始前必须移动的距离，以像素计。该选项可以防止点击在某个元素上时不必要的拖拽。
		 *
		 * @property options.distance
		 * @type {Number}
		 * @default 1
		 * @example
		 *	//初始化带有指定 distance 选项的 draggable：
		 *	$( &quot;.selector&quot; ).draggable({ distance: 10 });
		 */


	},
	_create: function() {

		if ( this.options.helper === &quot;original&quot; ) {
			this._setPositionRelative();
		}
		if (this.options.addClasses){
			this.element.addClass(&quot;ui-draggable&quot;);
		}
		if (this.options.disabled){
			this.element.addClass(&quot;ui-draggable-disabled&quot;);
		}
		this._setHandleClassName();

		this._mouseInit();
	},

	_setOption: function( key, value ) {
		this._super( key, value );
		if ( key === &quot;handle&quot; ) {
			this._removeHandleClassName();
			this._setHandleClassName();
		}
	},

	_destroy: function() {
		if ( ( this.helper || this.element ).is( &quot;.ui-draggable-dragging&quot; ) ) {
			this.destroyOnClear = true;
			return;
		}
		this.element.removeClass( &quot;ui-draggable ui-draggable-dragging ui-draggable-disabled&quot; );
		this._removeHandleClassName();
		this._mouseDestroy();
	},

	_mouseCapture: function(event) {
		var o = this.options;

		this._blurActiveElement( event );

		// among others, prevent a drag on a resizable-handle
		if (this.helper || o.disabled || $(event.target).closest(&quot;.ui-resizable-handle&quot;).length &gt; 0) {
			return false;
		}

		//Quit if we&#x27;re not on a valid handle
		this.handle = this._getHandle(event);
		if (!this.handle) {
			return false;
		}

		$(o.iframeFix === true ? &quot;iframe&quot; : o.iframeFix).each(function() {
			$(&quot;&lt;div class=&#x27;ui-draggable-iframeFix&#x27; style=&#x27;background: #fff;&#x27;&gt;&lt;/div&gt;&quot;)
			.css({
				width: this.offsetWidth + &quot;px&quot;, height: this.offsetHeight + &quot;px&quot;,
				position: &quot;absolute&quot;, opacity: &quot;0.001&quot;, zIndex: 1000
			})
			.css($(this).offset())
			.appendTo(&quot;body&quot;);
		});

		return true;

	},

	_blurActiveElement: function( event ) {
		var document = this.document[ 0 ];

		// Only need to blur if the event occurred on the draggable itself, see #10527
		if ( !this.handleElement.is( event.target ) ) {
			return;
		}

		// support: IE9
		// IE9 throws an &quot;Unspecified error&quot; accessing document.activeElement from an &lt;iframe&gt;
		try {

			// Support: IE9, IE10
			// If the &lt;body&gt; is blurred, IE will switch windows, see #9520
			if ( document.activeElement &amp;&amp; document.activeElement.nodeName.toLowerCase() !== &quot;body&quot; ) {

				// Blur any element that currently has focus, see #4261
				$( document.activeElement ).blur();
			}
		} catch ( error ) {}
	},

	_mouseStart: function(event) {

		var o = this.options;

		//Create and append the visible helper
		this.helper = this._createHelper(event);

		this.helper.addClass(&quot;ui-draggable-dragging&quot;);

		//Cache the helper size
		this._cacheHelperProportions();

		//If ddmanager is used for droppables, set the global draggable
		if ($.ui.ddmanager) {
			$.ui.ddmanager.current = this;
		}

		/*
		 * - Position generation -
		 * This block generates everything position related - it&#x27;s the core of draggables.
		 */

		//Cache the margins of the original element
		this._cacheMargins();

		//Store the helper&#x27;s css position
		this.cssPosition = this.helper.css( &quot;position&quot; );
		this.scrollParent = this.helper.scrollParent( true );
		this.offsetParent = this.helper.offsetParent();
		this.offsetParentCssPosition = this.offsetParent.css( &quot;position&quot; );

		//The element&#x27;s absolute position on the page minus margins
		this.offset = this.positionAbs = this.element.offset();
		this.offset = {
			top: this.offset.top - this.margins.top,
			left: this.offset.left - this.margins.left
		};

		//Reset scroll cache
		this.offset.scroll = false;

		$.extend(this.offset, {
			click: { //Where the click happened, relative to the element
				left: event.pageX - this.offset.left,
				top: event.pageY - this.offset.top
			},
			parent: this._getParentOffset(),
			relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
		});

		//Generate the original position
		this.originalPosition = this.position = this._generatePosition( event, false );
		this.originalPageX = event.pageX;
		this.originalPageY = event.pageY;

		//Adjust the mouse offset relative to the helper if &quot;cursorAt&quot; is supplied
		(o.cursorAt &amp;&amp; this._adjustOffsetFromHelper(o.cursorAt));

		//Set a containment if given in the options
		this._setContainment();

		//Trigger event + callbacks
		if (this._trigger(&quot;start&quot;, event) === false) {
			this._clear();
			return false;
		}

		//Recache the helper size
		this._cacheHelperProportions();

		//Prepare the droppable offsets
		if ($.ui.ddmanager &amp;&amp; !o.dropBehaviour) {
			$.ui.ddmanager.prepareOffsets(this, event);
		}

		// Reset helper&#x27;s right/bottom css if they&#x27;re set and set explicit width/height instead
		// as this prevents resizing of elements with right/bottom set (see #7772)
		this._normalizeRightBottom();

		this._mouseDrag(event, true); //Execute the drag once - this causes the helper not to be visible before getting its correct position

		//If the ddmanager is used for droppables, inform the manager that dragging has started (see #5003)
		if ( $.ui.ddmanager ) {
			$.ui.ddmanager.dragStart(this, event);
		}

		return true;
	},

	_mouseDrag: function(event, noPropagation) {
		// reset any necessary cached properties (see #5009)
		if ( this.offsetParentCssPosition === &quot;fixed&quot; ) {
			this.offset.parent = this._getParentOffset();
		}

		//Compute the helpers position
		this.position = this._generatePosition( event, true );
		this.positionAbs = this._convertPositionTo(&quot;absolute&quot;);

		//Call plugins and callbacks and use the resulting position if something is returned
		if (!noPropagation) {
			var ui = this._uiHash();
			if (this._trigger(&quot;drag&quot;, event, ui) === false) {
				this._mouseUp({});
				return false;
			}
			this.position = ui.position;
		}

		this.helper[ 0 ].style.left = this.position.left + &quot;px&quot;;
		this.helper[ 0 ].style.top = this.position.top + &quot;px&quot;;

		if ($.ui.ddmanager) {
			$.ui.ddmanager.drag(this, event);
		}

		return false;
	},

	_mouseStop: function(event) {

		//If we are using droppables, inform the manager about the drop
		var that = this,
			dropped = false;
		if ($.ui.ddmanager &amp;&amp; !this.options.dropBehaviour) {
			dropped = $.ui.ddmanager.drop(this, event);
		}

		//if a drop comes from outside (a sortable)
		if (this.dropped) {
			dropped = this.dropped;
			this.dropped = false;
		}

		if ((this.options.revert === &quot;invalid&quot; &amp;&amp; !dropped) || (this.options.revert === &quot;valid&quot; &amp;&amp; dropped) || this.options.revert === true || ($.isFunction(this.options.revert) &amp;&amp; this.options.revert.call(this.element, dropped))) {
			$(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function() {
				if (that._trigger(&quot;stop&quot;, event) !== false) {
					that._clear();
				}
			});
		} else {
			if (this._trigger(&quot;stop&quot;, event) !== false) {
				this._clear();
			}
		}

		return false;
	},

	_mouseUp: function(event) {
		//Remove frame helpers
		$(&quot;div.ui-draggable-iframeFix&quot;).each(function() {
			this.parentNode.removeChild(this);
		});

		//If the ddmanager is used for droppables, inform the manager that dragging has stopped (see #5003)
		if ( $.ui.ddmanager ) {
			$.ui.ddmanager.dragStop(this, event);
		}

		// Only need to focus if the event occurred on the draggable itself, see #10527
		if ( this.handleElement.is( event.target ) ) {
			// The interaction is over; whether or not the click resulted in a drag, focus the element
			this.element.focus();
		}

		return $.ui.mouse.prototype._mouseUp.call(this, event);
	},

	cancel: function() {

		if (this.helper.is(&quot;.ui-draggable-dragging&quot;)) {
			this._mouseUp({});
		} else {
			this._clear();
		}

		return this;

	},

	_getHandle: function(event) {
		return this.options.handle ?
			!!$( event.target ).closest( this.element.find( this.options.handle ) ).length :
			true;
	},

	_setHandleClassName: function() {
		this.handleElement = this.options.handle ?
			this.element.find( this.options.handle ) : this.element;
		this.handleElement.addClass( &quot;ui-draggable-handle&quot; );
	},

	_removeHandleClassName: function() {
		this.handleElement.removeClass( &quot;ui-draggable-handle&quot; );
	},

	_createHelper: function(event) {

		var o = this.options,
			helperIsFunction = $.isFunction( o.helper ),
			helper = helperIsFunction ?
				$( o.helper.apply( this.element[ 0 ], [ event ] ) ) :
				( o.helper === &quot;clone&quot; ?
					this.element.clone().removeAttr( &quot;id&quot; ) :
					this.element );

		if (!helper.parents(&quot;body&quot;).length) {
			helper.appendTo((o.appendTo === &quot;parent&quot; ? this.element[0].parentNode : o.appendTo));
		}

		// http://bugs.jqueryui.com/ticket/9446
		// a helper function can return the original element
		// which wouldn&#x27;t have been set to relative in _create
		if ( helperIsFunction &amp;&amp; helper[ 0 ] === this.element[ 0 ] ) {
			this._setPositionRelative();
		}

		if (helper[0] !== this.element[0] &amp;&amp; !(/(fixed|absolute)/).test(helper.css(&quot;position&quot;))) {
			helper.css(&quot;position&quot;, &quot;absolute&quot;);
		}

		return helper;

	},

	_setPositionRelative: function() {
		if ( !( /^(?:r|a|f)/ ).test( this.element.css( &quot;position&quot; ) ) ) {
			this.element[ 0 ].style.position = &quot;relative&quot;;
		}
	},

	_adjustOffsetFromHelper: function(obj) {
		if (typeof obj === &quot;string&quot;) {
			obj = obj.split(&quot; &quot;);
		}
		if ($.isArray(obj)) {
			obj = { left: +obj[0], top: +obj[1] || 0 };
		}
		if (&quot;left&quot; in obj) {
			this.offset.click.left = obj.left + this.margins.left;
		}
		if (&quot;right&quot; in obj) {
			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
		}
		if (&quot;top&quot; in obj) {
			this.offset.click.top = obj.top + this.margins.top;
		}
		if (&quot;bottom&quot; in obj) {
			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
		}
	},

	_isRootNode: function( element ) {
		return ( /(html|body)/i ).test( element.tagName ) || element === this.document[ 0 ];
	},

	_getParentOffset: function() {

		//Get the offsetParent and cache its position
		var po = this.offsetParent.offset(),
			document = this.document[ 0 ];

		// This is a special case where we need to modify a offset calculated on start, since the following happened:
		// 1. The position of the helper is absolute, so it&#x27;s position is calculated based on the next positioned parent
		// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn&#x27;t the document, which means that
		//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
		if (this.cssPosition === &quot;absolute&quot; &amp;&amp; this.scrollParent[0] !== document &amp;&amp; $.contains(this.scrollParent[0], this.offsetParent[0])) {
			po.left += this.scrollParent.scrollLeft();
			po.top += this.scrollParent.scrollTop();
		}

		if ( this._isRootNode( this.offsetParent[ 0 ] ) ) {
			po = { top: 0, left: 0 };
		}

		return {
			top: po.top + (parseInt(this.offsetParent.css(&quot;borderTopWidth&quot;),10) || 0),
			left: po.left + (parseInt(this.offsetParent.css(&quot;borderLeftWidth&quot;),10) || 0)
		};

	},

	_getRelativeOffset: function() {
		if ( this.cssPosition !== &quot;relative&quot; ) {
			return { top: 0, left: 0 };
		}

		var p = this.element.position(),
			scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] );

		return {
			top: p.top - ( parseInt(this.helper.css( &quot;top&quot; ), 10) || 0 ) + ( !scrollIsRootNode ? this.scrollParent.scrollTop() : 0 ),
			left: p.left - ( parseInt(this.helper.css( &quot;left&quot; ), 10) || 0 ) + ( !scrollIsRootNode ? this.scrollParent.scrollLeft() : 0 )
		};

	},

	_cacheMargins: function() {
		this.margins = {
			left: (parseInt(this.element.css(&quot;marginLeft&quot;),10) || 0),
			top: (parseInt(this.element.css(&quot;marginTop&quot;),10) || 0),
			right: (parseInt(this.element.css(&quot;marginRight&quot;),10) || 0),
			bottom: (parseInt(this.element.css(&quot;marginBottom&quot;),10) || 0)
		};
	},

	_cacheHelperProportions: function() {
		this.helperProportions = {
			width: this.helper.outerWidth(),
			height: this.helper.outerHeight()
		};
	},

	_setContainment: function() {

		var isUserScrollable, c, ce,
			o = this.options,
			document = this.document[ 0 ];

		this.relativeContainer = null;

		if ( !o.containment ) {
			this.containment = null;
			return;
		}

		if ( o.containment === &quot;window&quot; ) {
			this.containment = [
				$( window ).scrollLeft() - this.offset.relative.left - this.offset.parent.left,
				$( window ).scrollTop() - this.offset.relative.top - this.offset.parent.top,
				$( window ).scrollLeft() + $( window ).width() - this.helperProportions.width - this.margins.left,
				$( window ).scrollTop() + ( $( window ).height() || document.body.parentNode.scrollHeight ) - this.helperProportions.height - this.margins.top
			];
			return;
		}

		if ( o.containment === &quot;document&quot;) {
			this.containment = [
				0,
				0,
				$( document ).width() - this.helperProportions.width - this.margins.left,
				( $( document ).height() || document.body.parentNode.scrollHeight ) - this.helperProportions.height - this.margins.top
			];
			return;
		}

		if ( o.containment.constructor === Array ) {
			this.containment = o.containment;
			return;
		}

		if ( o.containment === &quot;parent&quot; ) {
			o.containment = this.helper[ 0 ].parentNode;
		}

		c = $( o.containment );
		ce = c[ 0 ];

		if ( !ce ) {
			return;
		}

		isUserScrollable = /(scroll|auto)/.test( c.css( &quot;overflow&quot; ) );

		this.containment = [
			( parseInt( c.css( &quot;borderLeftWidth&quot; ), 10 ) || 0 ) + ( parseInt( c.css( &quot;paddingLeft&quot; ), 10 ) || 0 ),
			( parseInt( c.css( &quot;borderTopWidth&quot; ), 10 ) || 0 ) + ( parseInt( c.css( &quot;paddingTop&quot; ), 10 ) || 0 ),
			( isUserScrollable ? Math.max( ce.scrollWidth, ce.offsetWidth ) : ce.offsetWidth ) -
				( parseInt( c.css( &quot;borderRightWidth&quot; ), 10 ) || 0 ) -
				( parseInt( c.css( &quot;paddingRight&quot; ), 10 ) || 0 ) -
				this.helperProportions.width -
				this.margins.left -
				this.margins.right,
			( isUserScrollable ? Math.max( ce.scrollHeight, ce.offsetHeight ) : ce.offsetHeight ) -
				( parseInt( c.css( &quot;borderBottomWidth&quot; ), 10 ) || 0 ) -
				( parseInt( c.css( &quot;paddingBottom&quot; ), 10 ) || 0 ) -
				this.helperProportions.height -
				this.margins.top -
				this.margins.bottom
		];
		this.relativeContainer = c;
	},

	_convertPositionTo: function(d, pos) {

		if (!pos) {
			pos = this.position;
		}

		var mod = d === &quot;absolute&quot; ? 1 : -1,
			scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] );

		return {
			top: (
				pos.top	+																// The absolute mouse position
				this.offset.relative.top * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.top * mod -										// The offsetParent&#x27;s offset without borders (offset + border)
				( ( this.cssPosition === &quot;fixed&quot; ? -this.offset.scroll.top : ( scrollIsRootNode ? 0 : this.offset.scroll.top ) ) * mod)
			),
			left: (
				pos.left +																// The absolute mouse position
				this.offset.relative.left * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.left * mod	-										// The offsetParent&#x27;s offset without borders (offset + border)
				( ( this.cssPosition === &quot;fixed&quot; ? -this.offset.scroll.left : ( scrollIsRootNode ? 0 : this.offset.scroll.left ) ) * mod)
			)
		};

	},

	_generatePosition: function( event, constrainPosition ) {

		var containment, co, top, left,
			o = this.options,
			scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] ),
			pageX = event.pageX,
			pageY = event.pageY;

		// Cache the scroll
		if ( !scrollIsRootNode || !this.offset.scroll ) {
			this.offset.scroll = {
				top: this.scrollParent.scrollTop(),
				left: this.scrollParent.scrollLeft()
			};
		}

		/*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 */

		// If we are not dragging yet, we won&#x27;t check for options
		if ( constrainPosition ) {
			if ( this.containment ) {
				if ( this.relativeContainer ){
					co = this.relativeContainer.offset();
					containment = [
						this.containment[ 0 ] + co.left,
						this.containment[ 1 ] + co.top,
						this.containment[ 2 ] + co.left,
						this.containment[ 3 ] + co.top
					];
				} else {
					containment = this.containment;
				}

				if (event.pageX - this.offset.click.left &lt; containment[0]) {
					pageX = containment[0] + this.offset.click.left;
				}
				if (event.pageY - this.offset.click.top &lt; containment[1]) {
					pageY = containment[1] + this.offset.click.top;
				}
				if (event.pageX - this.offset.click.left &gt; containment[2]) {
					pageX = containment[2] + this.offset.click.left;
				}
				if (event.pageY - this.offset.click.top &gt; containment[3]) {
					pageY = containment[3] + this.offset.click.top;
				}
			}

			if (o.grid) {
				//Check for grid elements set to 0 to prevent divide by 0 error causing invalid argument errors in IE (see ticket #6950)
				top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY;
				pageY = containment ? ((top - this.offset.click.top &gt;= containment[1] || top - this.offset.click.top &gt; containment[3]) ? top : ((top - this.offset.click.top &gt;= containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;

				left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX;
				pageX = containment ? ((left - this.offset.click.left &gt;= containment[0] || left - this.offset.click.left &gt; containment[2]) ? left : ((left - this.offset.click.left &gt;= containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
			}

			if ( o.axis === &quot;y&quot; ) {
				pageX = this.originalPageX;
			}

			if ( o.axis === &quot;x&quot; ) {
				pageY = this.originalPageY;
			}
		}

		return {
			top: (
				pageY -																	// The absolute mouse position
				this.offset.click.top	-												// Click offset (relative to the element)
				this.offset.relative.top -												// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.top +												// The offsetParent&#x27;s offset without borders (offset + border)
				( this.cssPosition === &quot;fixed&quot; ? -this.offset.scroll.top : ( scrollIsRootNode ? 0 : this.offset.scroll.top ) )
			),
			left: (
				pageX -																	// The absolute mouse position
				this.offset.click.left -												// Click offset (relative to the element)
				this.offset.relative.left -												// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.left +												// The offsetParent&#x27;s offset without borders (offset + border)
				( this.cssPosition === &quot;fixed&quot; ? -this.offset.scroll.left : ( scrollIsRootNode ? 0 : this.offset.scroll.left ) )
			)
		};

	},

	_clear: function() {
		this.helper.removeClass(&quot;ui-draggable-dragging&quot;);
		if (this.helper[0] !== this.element[0] &amp;&amp; !this.cancelHelperRemoval) {
			this.helper.remove();
		}
		this.helper = null;
		this.cancelHelperRemoval = false;
		if ( this.destroyOnClear ) {
			this.destroy();
		}
	},

	_normalizeRightBottom: function() {
		if ( this.options.axis !== &quot;y&quot; &amp;&amp; this.helper.css( &quot;right&quot; ) !== &quot;auto&quot; ) {
			this.helper.width( this.helper.width() );
			this.helper.css( &quot;right&quot;, &quot;auto&quot; );
		}
		if ( this.options.axis !== &quot;x&quot; &amp;&amp; this.helper.css( &quot;bottom&quot; ) !== &quot;auto&quot; ) {
			this.helper.height( this.helper.height() );
			this.helper.css( &quot;bottom&quot;, &quot;auto&quot; );
		}
	},

	// From now on bulk stuff - mainly helpers

	_trigger: function(type, event, ui) {
		ui = ui || this._uiHash();
		$.ui.plugin.call( this, type, [ event, ui, this ], true );

		// Absolute position and offset (see #6884 ) have to be recalculated after plugins
		if ( /^(drag|start|stop)/.test( type ) ) {
			this.positionAbs = this._convertPositionTo( &quot;absolute&quot; );
			ui.offset = this.positionAbs;
		}
		return $.Widget.prototype._trigger.call(this, type, event, ui);
	},

	plugins: {},

	_uiHash: function() {
		return {
			helper: this.helper,
			position: this.position,
			originalPosition: this.originalPosition,
			offset: this.positionAbs
		};
	}

});

$.ui.plugin.add(&quot;draggable&quot;, &quot;connectToSortable&quot;, {
	start: function( event, ui, inst ) {

		var o = inst.options,
			uiSortable = $.extend({}, ui, { item: inst.element });
		inst.sortables = [];
		$(o.connectToSortable).each(function() {
			var sortable = $( this ).sortable( &quot;instance&quot; );
			if (sortable &amp;&amp; !sortable.options.disabled) {
				inst.sortables.push({
					instance: sortable,
					shouldRevert: sortable.options.revert
				});
				sortable.refreshPositions();	// Call the sortable&#x27;s refreshPositions at drag start to refresh the containerCache since the sortable container cache is used in drag and needs to be up to date (this will ensure it&#x27;s initialised as well as being kept in step with any changes that might have happened on the page).
				sortable._trigger(&quot;activate&quot;, event, uiSortable);
			}
		});

	},
	stop: function( event, ui, inst ) {

		//If we are still over the sortable, we fake the stop event of the sortable, but also remove helper
		var uiSortable = $.extend( {}, ui, {
			item: inst.element
		});

		$.each(inst.sortables, function() {
			if (this.instance.isOver) {

				this.instance.isOver = 0;

				inst.cancelHelperRemoval = true; //Don&#x27;t remove the helper in the draggable instance
				this.instance.cancelHelperRemoval = false; //Remove it in the sortable instance (so sortable plugins like revert still work)

				//The sortable revert is supported, and we have to set a temporary dropped variable on the draggable to support revert: &quot;valid/invalid&quot;
				if (this.shouldRevert) {
					this.instance.options.revert = this.shouldRevert;
				}

				//Trigger the stop of the sortable
				this.instance._mouseStop(event);

				this.instance.options.helper = this.instance.options._helper;

				//If the helper has been the original item, restore properties in the sortable
				if (inst.options.helper === &quot;original&quot;) {
					this.instance.currentItem.css({ top: &quot;auto&quot;, left: &quot;auto&quot; });
				}

			} else {
				this.instance.cancelHelperRemoval = false; //Remove the helper in the sortable instance
				this.instance._trigger(&quot;deactivate&quot;, event, uiSortable);
			}

		});

	},
	drag: function( event, ui, inst ) {

		var that = this;

		$.each(inst.sortables, function() {

			var innermostIntersecting = false,
				thisSortable = this;

			//Copy over some variables to allow calling the sortable&#x27;s native _intersectsWith
			this.instance.positionAbs = inst.positionAbs;
			this.instance.helperProportions = inst.helperProportions;
			this.instance.offset.click = inst.offset.click;

			if (this.instance._intersectsWith(this.instance.containerCache)) {
				innermostIntersecting = true;
				$.each(inst.sortables, function() {
					this.instance.positionAbs = inst.positionAbs;
					this.instance.helperProportions = inst.helperProportions;
					this.instance.offset.click = inst.offset.click;
					if (this !== thisSortable &amp;&amp;
						this.instance._intersectsWith(this.instance.containerCache) &amp;&amp;
						$.contains(thisSortable.instance.element[0], this.instance.element[0])
					) {
						innermostIntersecting = false;
					}
					return innermostIntersecting;
				});
			}

			if (innermostIntersecting) {
				//If it intersects, we use a little isOver variable and set it once, so our move-in stuff gets fired only once
				if (!this.instance.isOver) {

					this.instance.isOver = 1;
					//Now we fake the start of dragging for the sortable instance,
					//by cloning the list group item, appending it to the sortable and using it as inst.currentItem
					//We can then fire the start event of the sortable with our passed browser event, and our own helper (so it doesn&#x27;t create a new one)
					this.instance.currentItem = $(that).clone().removeAttr(&quot;id&quot;).appendTo(this.instance.element).data(&quot;ui-sortable-item&quot;, true);
					this.instance.options._helper = this.instance.options.helper; //Store helper option to later restore it
					this.instance.options.helper = function() { return ui.helper[0]; };

					event.target = this.instance.currentItem[0];
					this.instance._mouseCapture(event, true);
					this.instance._mouseStart(event, true, true);

					//Because the browser event is way off the new appended portlet, we modify a couple of variables to reflect the changes
					this.instance.offset.click.top = inst.offset.click.top;
					this.instance.offset.click.left = inst.offset.click.left;
					this.instance.offset.parent.left -= inst.offset.parent.left - this.instance.offset.parent.left;
					this.instance.offset.parent.top -= inst.offset.parent.top - this.instance.offset.parent.top;

					inst._trigger(&quot;toSortable&quot;, event);
					inst.dropped = this.instance.element; //draggable revert needs that
					//hack so receive/update callbacks work (mostly)
					inst.currentItem = inst.element;
					this.instance.fromOutside = inst;

				}

				//Provided we did all the previous steps, we can fire the drag event of the sortable on every draggable drag, when it intersects with the sortable
				if (this.instance.currentItem) {
					this.instance._mouseDrag(event);
				}

			} else {

				//If it doesn&#x27;t intersect with the sortable, and it intersected before,
				//we fake the drag stop of the sortable, but make sure it doesn&#x27;t remove the helper by using cancelHelperRemoval
				if (this.instance.isOver) {

					this.instance.isOver = 0;
					this.instance.cancelHelperRemoval = true;

					//Prevent reverting on this forced stop
					this.instance.options.revert = false;

					// The out event needs to be triggered independently
					this.instance._trigger(&quot;out&quot;, event, this.instance._uiHash(this.instance));

					this.instance._mouseStop(event, true);
					this.instance.options.helper = this.instance.options._helper;

					//Now we remove our currentItem, the list group clone again, and the placeholder, and animate the helper back to it&#x27;s original size
					this.instance.currentItem.remove();
					if (this.instance.placeholder) {
						this.instance.placeholder.remove();
					}

					inst._trigger(&quot;fromSortable&quot;, event);
					inst.dropped = false; //draggable revert needs that
				}

			}

		});

	}
});

$.ui.plugin.add(&quot;draggable&quot;, &quot;cursor&quot;, {
	start: function( event, ui, instance ) {
		var t = $( &quot;body&quot; ),
			o = instance.options;

		if (t.css(&quot;cursor&quot;)) {
			o._cursor = t.css(&quot;cursor&quot;);
		}
		t.css(&quot;cursor&quot;, o.cursor);
	},
	stop: function( event, ui, instance ) {
		var o = instance.options;
		if (o._cursor) {
			$(&quot;body&quot;).css(&quot;cursor&quot;, o._cursor);
		}
	}
});

$.ui.plugin.add(&quot;draggable&quot;, &quot;opacity&quot;, {
	start: function( event, ui, instance ) {
		var t = $( ui.helper ),
			o = instance.options;
		if (t.css(&quot;opacity&quot;)) {
			o._opacity = t.css(&quot;opacity&quot;);
		}
		t.css(&quot;opacity&quot;, o.opacity);
	},
	stop: function( event, ui, instance ) {
		var o = instance.options;
		if (o._opacity) {
			$(ui.helper).css(&quot;opacity&quot;, o._opacity);
		}
	}
});

$.ui.plugin.add(&quot;draggable&quot;, &quot;scroll&quot;, {
	start: function( event, ui, i ) {
		if ( !i.scrollParentNotHidden ) {
			i.scrollParentNotHidden = i.helper.scrollParent( false );
		}

		if ( i.scrollParentNotHidden[ 0 ] !== i.document[ 0 ] &amp;&amp; i.scrollParentNotHidden[ 0 ].tagName !== &quot;HTML&quot; ) {
			i.overflowOffset = i.scrollParentNotHidden.offset();
		}
	},
	drag: function( event, ui, i  ) {

		var o = i.options,
			scrolled = false,
			scrollParent = i.scrollParentNotHidden[ 0 ],
			document = i.document[ 0 ];

		if ( scrollParent !== document &amp;&amp; scrollParent.tagName !== &quot;HTML&quot; ) {
			if ( !o.axis || o.axis !== &quot;x&quot; ) {
				if ( ( i.overflowOffset.top + scrollParent.offsetHeight ) - event.pageY &lt; o.scrollSensitivity ) {
					scrollParent.scrollTop = scrolled = scrollParent.scrollTop + o.scrollSpeed;
				} else if ( event.pageY - i.overflowOffset.top &lt; o.scrollSensitivity ) {
					scrollParent.scrollTop = scrolled = scrollParent.scrollTop - o.scrollSpeed;
				}
			}

			if ( !o.axis || o.axis !== &quot;y&quot; ) {
				if ( ( i.overflowOffset.left + scrollParent.offsetWidth ) - event.pageX &lt; o.scrollSensitivity ) {
					scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft + o.scrollSpeed;
				} else if ( event.pageX - i.overflowOffset.left &lt; o.scrollSensitivity ) {
					scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft - o.scrollSpeed;
				}
			}

		} else {

			if (!o.axis || o.axis !== &quot;x&quot;) {
				if (event.pageY - $(document).scrollTop() &lt; o.scrollSensitivity) {
					scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
				} else if ($(window).height() - (event.pageY - $(document).scrollTop()) &lt; o.scrollSensitivity) {
					scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
				}
			}

			if (!o.axis || o.axis !== &quot;y&quot;) {
				if (event.pageX - $(document).scrollLeft() &lt; o.scrollSensitivity) {
					scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
				} else if ($(window).width() - (event.pageX - $(document).scrollLeft()) &lt; o.scrollSensitivity) {
					scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
				}
			}

		}

		if (scrolled !== false &amp;&amp; $.ui.ddmanager &amp;&amp; !o.dropBehaviour) {
			$.ui.ddmanager.prepareOffsets(i, event);
		}

	}
});

$.ui.plugin.add(&quot;draggable&quot;, &quot;snap&quot;, {
	start: function( event, ui, i ) {

		var o = i.options;

		i.snapElements = [];

		$(o.snap.constructor !== String ? ( o.snap.items || &quot;:data(ui-draggable)&quot; ) : o.snap).each(function() {
			var $t = $(this),
				$o = $t.offset();
			if (this !== i.element[0]) {
				i.snapElements.push({
					item: this,
					width: $t.outerWidth(), height: $t.outerHeight(),
					top: $o.top, left: $o.left
				});
			}
		});

	},
	drag: function( event, ui, inst ) {

		var ts, bs, ls, rs, l, r, t, b, i, first,
			o = inst.options,
			d = o.snapTolerance,
			x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width,
			y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;

		for (i = inst.snapElements.length - 1; i &gt;= 0; i--){

			l = inst.snapElements[i].left - inst.margins.left;
			r = l + inst.snapElements[i].width;
			t = inst.snapElements[i].top - inst.margins.top;
			b = t + inst.snapElements[i].height;

			if ( x2 &lt; l - d || x1 &gt; r + d || y2 &lt; t - d || y1 &gt; b + d || !$.contains( inst.snapElements[ i ].item.ownerDocument, inst.snapElements[ i ].item ) ) {
				if (inst.snapElements[i].snapping) {
					(inst.options.snap.release &amp;&amp; inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
				}
				inst.snapElements[i].snapping = false;
				continue;
			}

			if (o.snapMode !== &quot;inner&quot;) {
				ts = Math.abs(t - y2) &lt;= d;
				bs = Math.abs(b - y1) &lt;= d;
				ls = Math.abs(l - x2) &lt;= d;
				rs = Math.abs(r - x1) &lt;= d;
				if (ts) {
					ui.position.top = inst._convertPositionTo(&quot;relative&quot;, { top: t - inst.helperProportions.height, left: 0 }).top;
				}
				if (bs) {
					ui.position.top = inst._convertPositionTo(&quot;relative&quot;, { top: b, left: 0 }).top;
				}
				if (ls) {
					ui.position.left = inst._convertPositionTo(&quot;relative&quot;, { top: 0, left: l - inst.helperProportions.width }).left;
				}
				if (rs) {
					ui.position.left = inst._convertPositionTo(&quot;relative&quot;, { top: 0, left: r }).left;
				}
			}

			first = (ts || bs || ls || rs);

			if (o.snapMode !== &quot;outer&quot;) {
				ts = Math.abs(t - y1) &lt;= d;
				bs = Math.abs(b - y2) &lt;= d;
				ls = Math.abs(l - x1) &lt;= d;
				rs = Math.abs(r - x2) &lt;= d;
				if (ts) {
					ui.position.top = inst._convertPositionTo(&quot;relative&quot;, { top: t, left: 0 }).top;
				}
				if (bs) {
					ui.position.top = inst._convertPositionTo(&quot;relative&quot;, { top: b - inst.helperProportions.height, left: 0 }).top;
				}
				if (ls) {
					ui.position.left = inst._convertPositionTo(&quot;relative&quot;, { top: 0, left: l }).left;
				}
				if (rs) {
					ui.position.left = inst._convertPositionTo(&quot;relative&quot;, { top: 0, left: r - inst.helperProportions.width }).left;
				}
			}

			if (!inst.snapElements[i].snapping &amp;&amp; (ts || bs || ls || rs || first)) {
				(inst.options.snap.snap &amp;&amp; inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
			}
			inst.snapElements[i].snapping = (ts || bs || ls || rs || first);

		}

	}
});

$.ui.plugin.add(&quot;draggable&quot;, &quot;stack&quot;, {
	start: function( event, ui, instance ) {
		var min,
			o = instance.options,
			group = $.makeArray($(o.stack)).sort(function(a, b) {
				return (parseInt($(a).css(&quot;zIndex&quot;), 10) || 0) - (parseInt($(b).css(&quot;zIndex&quot;), 10) || 0);
			});

		if (!group.length) { return; }

		min = parseInt($(group[0]).css(&quot;zIndex&quot;), 10) || 0;
		$(group).each(function(i) {
			$(this).css(&quot;zIndex&quot;, min + i);
		});
		this.css(&quot;zIndex&quot;, (min + group.length));
	}
});

$.ui.plugin.add(&quot;draggable&quot;, &quot;zIndex&quot;, {
	start: function( event, ui, instance ) {
		var t = $( ui.helper ),
			o = instance.options;

		if (t.css(&quot;zIndex&quot;)) {
			o._zIndex = t.css(&quot;zIndex&quot;);
		}
		t.css(&quot;zIndex&quot;, o.zIndex);
	},
	stop: function( event, ui, instance ) {
		var o = instance.options;

		if (o._zIndex) {
			$(ui.helper).css(&quot;zIndex&quot;, o._zIndex);
		}
	}
});

return $.ui.draggable;

}));

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
